# 3.

実用的なデータ構造の多くは関数型の環境に適応させるのは困難・もしくは不可能であるが、いくつかは簡単に実装することができる。
この章ではそのうち3つの実用的とされているデータ構造を見ていく。
1つめのleftist heapsで、他の2つのデータ構造(binomial queues と red-black trees)に比べるとかなりシンプルではあるが、ポインタの操作が面倒な複雑な表現である。
逆に言えば、これらの構造の関数型での実装は、面倒なポインタ操作の問題をなくし、高レベルのアイディアをそのまま反映することができる。
この利点はtreeの実装においても同様である。

## 3.1 Leftist Heaps

集合と有限マップを用いると任意の要素に効果的にアクセスできる。
しかし、最小の要素にのみアクセスしたい時がしばしばある。
データ構造はこの種のアクセスを *プライオリティキュー* もしくは *ヒープ* と呼ぶ。
FIFOキューとの混乱を避けるため、この本ではヒープと呼ぶことにする。
図3.1にヒープの簡単なシグネチャを示す。

**注意**
ヒープと集合のシグネチャを比較すると、前者では要素の順序関係がシグネチャに含まれているが、後者はそうではない(図2.7)。
順序関係がヒープの意味論ではクリティカルであるが、集合ではそうではないということがこの矛盾を生み出す。
一方で、等価関係が集合の意味論ではクリティカルであるから、シグネチャに含まれるべきだと主張することも可能だ。

ヒープは heap-orderd tree として実装されることが多く、それぞれのノードの要素が子ノードの要素以下になる。
この規則に従うと、最小の要素は常にルートになる。

left heap は leftist property を満たす heap-ordered binary tree である。
leftist property は、任意の左の子ノードのランクが、それより右の兄弟ノードのランク以上であることを満たす。
ノードのランクは、右の背骨(そのノードからから空ノードへの最も右のパス)の長さと定義される。
leftist property の結果、任意のノードの右の背骨は常に空ノードへの最短パスとなる。

**問題 3.1**
サイズ `n` の leftist heap の右の背骨はたかだか hoge 個の要素である。

順序付けられた要素のいくつかの構造 `Elem` があるとき、ランク情報で飾り付けられた二分木として leftist heap を表現する。

```
定義
```

leftist heap の右背骨上にある要素は順番通りに並べられている。
leftist heap の鍵となる知見は、2つのヒープは右背骨をマージして、leftist propertyを保つためにこのパス上のノードの子ノードを入れ替える。
実装は次の通りである。

```
数式
```

`makeT` はTのノードのランクを計算し、必要であれば子ノードの入れ替えを行う補助関数である。

```
数式
```

それぞれの右背骨はたかだか対数なので、 `O(logn)` 時間でマージできる。

今効率的なマージ関数を手に入れたところで、あとは自明な関数ばかりだ。
*insert* はノード数1の木を作って既存のヒープにマージする。
*findMin* はルートの要素を返す。
*deleteMin* はルートを取り除き、子ノードをマージする。
マージは `O(logn)` なので、 *insert* も *deleteMin* も `O(logn)` である。
findMin は明らかに `O(1)` である。
leftist heap の完全な実装は、順序付けられた要素の構造をパラメータとして受け取るファンクタとして図3.2に示す。

**注意**
例が散逸するのを避けるため、コードの一部を記述する際にはエラーを省略する。
例えば、上記のコードでは空のヒープに対する `findMin` や `deleteMin` の振る舞いを記述していない。
図3.2のように完全な実装を示す際は常にエラーも含めて記述する。

**問題3.2**
`merge` を使用せずに `insert` を定義せよ。

**問題3.3**
`fromList` を実装せよ。
型は `Elem.t list -> Heap` で、それぞれの要素を singleton のheapに変換し、それらをマージすることによって順序付けされてないリストから leftist heap を生成する。
隣接するヒープをマージする際は、右から左、もしくは左から右にヒープをマージするのではなく、 `foldl` や `foldr` を使うことで、 `floor(log n)` 回の手順でマージできる。
`fromLIst` が `O(n)` であることを示せ。

**問題3.4** (Cho and Sahni)
weight-biased leftist heap は leftist heap の一種で、leftist property を wight-biased leftist property に置き換えたものである。任意の左の子のサイズは、少なくも右側の兄弟ノードのサイズ以上である。

- (a) weight-biased leftist heap の右の脊柱はたかだか `floor(log(n+1))` の要素を持つことを示せ。
- (b) 図3.2の実装を変えて、weight-biased leftist heap を得よ。
- (c) 今のところ、マージ操作は(1)トップダウンでマージを呼び出し、(2)ボトムアップで補助関数の `makeT` を呼び出すという2つの手続きで成り立っている。これをトップダウンの手続きのみで実現せよ。
- (d) トップダウン版のマージが遅延環境・concurrent環境)においてもつ利点は？

## 3.2 二項ヒープ
その他の有名なヒープとして、binomial queue を紹介する。以降、FIFO queue との混同を避けるため、二項ヒープと呼ぶ。
二項ヒープは leftist heap に比べ複雑で、最初は何も利点がないように見える。
しかし、後の章で binomial heap の亜種に対して挿入やマージを `O(1)` で行う方法を紹介する。

二項ヒープは二項木として知られるより基本的なオブジェクトで構成されている。
二項木は次のように帰納的に定義される。

- ランク0の二項木は、1ノードの木である
- ランク `r+1` の二項木は、2つのランク `r` の二項木をつなげたもので、一方の木の子をもう一方の木とする(？)

この定義より、ランク `r` 木はちょうど `2^r` 個のノードを持つことがわかる。また、ランク `r` の二項木は、 `r` 個の子 `t_1 ... t_r`を持ち、 `t_i` はそれぞれランク `r - i` の二項木となる。図3.3にランク0から3までの二項木を示した。

二項木におけるノードは、要素と子のリストとして表す。便宜上、それぞれのランクで注釈をつけておく。

```
datatype Tree = Node of int × Elem. T × Tree list
```

子となるそれぞれのリストはランクの降順に並んでおり、要素はヒープ順(？)に並んでいる。ヒープ順を保つため、小さいルートの木の下に大きいルートの木をつなげるようにする。

```
fun link ...
```

常に同じランクの木をつなげる。(？)

二項ヒープは互いに同じランクでないヒープオーダの二項木の集まりである。この集まりはランクの昇順で並ぶ木のリストとして表現される。

```
type Heap = Tree list
```

二項木は `2^r` 個の要素を持ち、互いに同じランクではないので、サイズ `n` の二項ヒープに含まれる木は、`n` の2進数における `0` と一致する。例えば、21の2進数表現は `10101` であるので、サイズ21の二項ヒープにはランク0,2,4の二項ヒープが含まれる。 `n` の2進数表現はたかだか `log(n+1)` 個しか `0` が含まれないので、サイズ `n` の二項ヒープはたかだか `log(n+1)` 個の木しか持たない。

これで二項ヒープに関する関数を表現する準備ができた。まずは、2進数の増加・追加と似たような定義をされる `insert` と `merge` からはじめる。(これについては第9章で定義する。)ヒープへ新しい要素を挿入するために、まずは1ノードの木(＝ランク0の二項木)を作成する。同じランクの木をlinkしながら、(ヒープに)存在しないランクを見つけるまでランクの昇順に並んでいる木を進んでいく。それぞれのlinkは2進法の桁上がりと一致する。

```
fun rank( Node( r, x, v ) ) = r
fun insTree( t, [] ) = [ t ]
  | insTree( t, ts as t'::ts' ) =
      if rank t < rank t' then t::ts else insTree( link( t, t' ), ts' )
fun insert( x, ts ) = insTree( Node( 0, x, []), ts )
```

最悪ケースは、サイズ `n(= 2^k - 1)` のヒープに挿入する場合で、 `k` リンク、つまり `O(k) = 0(log n)`時間かかる。

2つのヒープをマージするには、同じランクの木をリンクしながらランクの昇順に2つの木のリストを進んでいく。同じように、linkは2進法の桁上がりと一致する。

```
fun merge( ts1, [] ) = ts1
  | merge( [], ts2 ) = ts2
  | merge( ts1 as t1::ts1', ts2 as t2::ts2 ) =
      if rank t1 < rank t2 then t1::merge( ts1', ts2 )
      else if rank t2 < rank t1 then t2::merge( ts1, ts2' )
      else insTree( link( t1, t2 ), merge( ts1', ts2' ))
```

`findMin` と `deleteMin` はどちらも `removeMinTree` の補助関数として呼ばれ、2つの木と残りのリストを返しながら、最小のルートを持つ木を探し、それをリストから除去する。

```
fun removeMinTree [t] = ( t, [] )
  | removeMinTree ( t::ts ) =
    let val ( t', ts' ) = removeMinTree ts
    in if Elem.leq( root t, root t' ) then ( t, ts ) else ( t', t::ts' ) end
```

`findMin` は抽出された木のルートを返す。

```
fun findMin ts = let val ( t, _ ) = removeMinTree ts in root t end
```

`deleteMin` 関数は少しトリッキーである。
抽出された木の根を取り除いた後、木の残りのリストから取り除かれたノードの子ノードをどうにかして返さなければいけない。
それぞれの子リストは、ほぼ正しい二項ヒープになっている。
それぞれはユニークなランクのヒープオーダーの二項木の集まりになっているが、降順ではなく昇順になっている。
このように、ひっくり返ることによって子リストを正しい二項ヒープに変換し、リストを残りの木にマージする。

```
fun deleteMin ts = let va ( Node( _, x, ts1 ), ts2 ) = removeMinTree ts
                   in merge( rev ts1, ts2 ) end
```

二項木の完璧な実装は図3.4に示す。4つの主要な操作の最悪ケースは `O(log n)` である。

**問題3.5**
`findMin` を `romoveMinTree` を用いずに実装せよ。

**問題3.6**
二項ヒープにおけるランクの注記のほとんどは省略できる。なぜなら、ランク `r` のノードの子ノードには `r-1` ,..., `0` のノードがあることがわかっているからである。このようにして、ランクの注記を取り除き、木のペアのトップレベルにのみラベルをつければ良い。

```sml
data type Tree = Node of Elem * Tree list
type Heap = (int * Tree) list
```

上記の通り二項ヒープを再実装せよ。

**問題3.7**
二項ヒープと比較したleftist heapの利点の一つとして、 `findMin` が `O(log n)` ではなく `O(1)` 時間であることである。
以下のファンクターの概略は、最小要素を残りのヒープとは別に保存することで、 `findMin` の計算時間を `O(1)` にしている。

```sml
functor ExplicitMin( H : Heap ) : Heap = 
struct
  structure Elem = H.Elem
  datatype Heap = E | NE of Elem.T * H.Heap
  (* 中略 *)
end
```

このファンクターは二項ヒープに特化したものではなく、ヒープのあらゆる実装に適応できることに注意してほしい。
このファンクターを完成させれば、 `findMin` は `O(1)` で、それ以外の `insert` `merger` `deleteMin` は `O(log n)` で操作することができる。
(実装 `H` のもとで４つの操作が `O(log n)` かそれより良いという仮定のもとで )

```sml
functor BinomialHeap( Element : Orderer ) : Heap = 
struct
  (* 本には書いてるけど省略 *)
end
```

## 3.3 赤黒木

2.2章で、二分探索木を紹介した。これらの木はランダム、もしくは順序付けされていないデータには向いているが、順序付けられたデータに対しては個々の操作に `O(n)` 時間かかることもあり、あまりよいパフォーマンスを発揮できない。
この問題の解決方法は、木のバランスをとることである。
木のバランスをとると、それぞれの操作が `O(log n)` より悪くなることはない。
赤黒木はバランスされた二分探索木の中でよく知られている木の1つである。

赤黒木はすべてのノードが赤・黒の2色に塗り分けられた二分木である。
第2.2章の二分探索木に色付けしたものである。

```sml
datatype Color = R | B
datatype Tree  = E | T of Color * Tree * Elem * Tree
```

すべての空ノードは黒とするので、空ノードのに色情報は付与しない。

すべての赤黒木は以下の2つのバランスの不変性を満たす。

- **不変性1.** 赤ノードは子ノードとして赤ノードを持たない
- **不変性2.** 根から葉への任意のパスに含まれる黒ノードの数は必ず等しい

この2つを合わせると、最も長いパス(赤と黒が交互に並ぶ)は最も短いパス(黒のみ)の2倍より長くなることはない。

**問題3.8** 赤黒木の深さは、たかだか `floor(log(n+1))` である。


赤黒木の所属関数は色情報を無視する。
`T` に含まれるワイルドカードを除けば、バランスされていない探索議における所属関数と同じである。

```sml
fun member( x, E ) = false
  | member( x, T ( _, a, y, b ) ) = 
      if x < y then member( x, a )
      else if x > y then member( x, b ) 
      else true
```

挿入関数は、二つの普遍性を維持しなければいけないため、もう少し面白い。

```sml
fun insert (x, s) =
  let fun ins E = T (R, E, x, E)
        | ins (s as T (color, a, y, b)) =
            if x < y then balance (color, ins a, y, b)
            else if x > y then balance (color, a, y, ins b)
            else s
      val T (_, a, y, b) = ins s
  in T (B, a, y, b) end
```

この関数は、
